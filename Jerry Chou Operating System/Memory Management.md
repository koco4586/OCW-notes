# Address binding
  -Multistep processing of a user program:![image](https://github.com/user-attachments/assets/91f9ce2a-2b18-4444-95b9-4bf7d30ceead)
  - Address binding - Compile time:
    - Program is written as symbolic code.  
    - Compiler translates symbolic code into **absolute code**.
    - If starting location changes, need to recompile.
    - ![image](https://github.com/user-attachments/assets/f26742af-835a-41a9-adf3-2b78d8030c31)
  - Address binding - Load time:
    - Compiler translates symbolic code into **relocatable code**.
      - **Realocatable code**: Machine language that can be run from any memory location.
    - If stating location changes, need to reload the code.
    - ![image](https://github.com/user-attachments/assets/5574883e-0b9c-4bf7-b41a-af82d32818dd)
  - Address binding - Run time:
    - Compiler translates symbolic code into **logical-address (vitual-address) code**.
    - Special **hardware (MMU)** is needed for this scheme.
    - Most general-purpose OS use this method.
    - ![image](https://github.com/user-attachments/assets/f0e771d9-beef-4fd3-b531-23ff4d3ab839)
  - Memory-Management Unit (MMU)
    - Hardware device that **maps virtual to physical address**.
    - The value in the relocation register is added to every address generated by a user process at the time it is sent to memory.
    - Logical address (virtual address): generated by CPU.
    - Physical address: seen by the memory module.
    - Complie time and load time address binding: logical address = physical address.
    - Run time address binding: logical address != physical address.
    - The user program deals with logical addresses; it never sees the real physical addresses.
# Static/dynamic loading and linking
- Dynamic loading: A routine is loaded into memory when it is called.
  - Better memory-space utilization
    - unused routine is never loaded
    - Particularly useful when large amounts of code are infrequently used (e.g. **error handling code**).
  - No special support from OS is required implemented through program.
  - Dynamic loading examples in C:
    - *dlopen()*: open a library and prepares it for use.
    - *desym()*: looks up the value of a symbol in a given library.
    - *dlclose()*: closes a DL library.
- Static Linking: libraries are combined by the linker into the program's final in-memory image at compile time. At runtime, the loader loads the in-memory image for execution.
  - Waste memory: **dulicated code**.
  - Faster during execution time.
- Dynamic Linking: linking is postponed **until execution time**.
  - Only one copy of the library code is loaded into memory and shared by everyone.
  - A stub is included in the program in-memory image for each lib reference.
  - Stub call -> check if the referred lib is in memory -> if not, load the lib.
  - DLL(Dynamic Linking Library) in Windows.
# Swap
- A process can be swapped out of memory to a **backing store**, and later brought back into memory for continuous execution.
- Backing store: a chunk of disk, **separated from file system**, to provide direct access to these memory images.
- 
# Page segment

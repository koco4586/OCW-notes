# Address binding
  -Multistep processing of a user program:![image](https://github.com/user-attachments/assets/91f9ce2a-2b18-4444-95b9-4bf7d30ceead)
  - Address binding - Compile time:
    - Program is written as symbolic code.  
    - Compiler translates symbolic code into **absolute code**.
    - If starting location changes, need to recompile.
    - ![image](https://github.com/user-attachments/assets/f26742af-835a-41a9-adf3-2b78d8030c31)
  - Address binding - Load time:
    - Compiler translates symbolic code into **relocatable code**.
      - **Realocatable code**: Machine language that can be run from any memory location.
    - If stating location changes, need to reload the code.
    - ![image](https://github.com/user-attachments/assets/5574883e-0b9c-4bf7-b41a-af82d32818dd)
  - Address binding - Run time:
    - Compiler translates symbolic code into **logical-address (vitual-address) code**.
    - Special **hardware (MMU)** is needed for this scheme.
    - Most general-purpose OS use this method.
    - ![image](https://github.com/user-attachments/assets/f0e771d9-beef-4fd3-b531-23ff4d3ab839)
  - Memory-Management Unit (MMU)
    - Hardware device that **maps virtual to physical address**.
    - The value in the relocation register is added to every address generated by a user process at the time it is sent to memory.
    - Logical address (virtual address): generated by CPU.
    - Physical address: seen by the memory module.
    - Complie time and load time address binding: logical address = physical address.
    - Run time address binding: logical address != physical address.
    - The user program deals with logical addresses; it never sees the real physical addresses.
# Static/dynamic loading and linking
- Dynamic loading: A routine is loaded into memory when it is called.
  - Better memory-space utilization
    - unused routine is never loaded
    - Particularly useful when large amounts of code are infrequently used (e.g. **error handling code**).
  - No special support from OS is required implemented through program.
  - Dynamic loading examples in C:
    - *dlopen()*: open a library and prepares it for use.
    - *desym()*: looks up the value of a symbol in a given library.
    - *dlclose()*: closes a DL library.
- Static Linking: libraries are combined by the linker into the program's final in-memory image at compile time. At runtime, the loader loads the in-memory image for execution.
  - Waste memory: **dulicated code**.
  - Faster during execution time.
- Dynamic Linking: linking is postponed **until execution time**.
  - Only one copy of the library code is loaded into memory and shared by everyone.
  - A stub is included in the program in-memory image for each lib reference.
  - Stub call -> check if the referred lib is in memory -> if not, load the lib.
  - DLL(Dynamic Linking Library) in Windows.
# Swap
- A process can be swapped out of memory to a **backing store**, and later brought back into memory for continuous execution.
- Backing store: a chunk of disk, **separated from file system**, to provide direct access to these memory images.
- Swap back memory location:
  - If binding is done at complie/load time: swap back memory address must be the **same**.
  - If binding is done at execution time: swap back memory address can be **different**.
- A process to be swapped must be idle.
  - Solutions:
    - Never swap a process with pending I/O.
    - I/O operations are done through **OS buffers**.
# Contigous Memory Allocation
- Fixed-partition allocation:
  - Each process loads into one partition of fixed-size.
  - Degree of multi-programming is bounded by the number of partitions.
- Variable-size partition:
  - Hole: block of contiguous free memory.
  - Holes of various size are scattered in memory.
    - First-Fit: allocate the first hole that fits.
    - Best-Fit: allocate the smallest hole that fits.
      - Must search through the whole list, lower speed.
- Fragmentation:
  - External fragmentation:
    - Total free space is big enough to satisfy a request, but is not contigous.
    - Occur in Variable-size allocation.
  - Internal fragmentation:
    - Memory that is internal to a partition but is not being used.
    - Occur in fixed-partition allocation
  - Solution: compaction
    - Shuffle the memory contents to place all free memory together in one large block at **execution time**.
    - Only if binding is done at execution time.   
# Non-Contiguous Memory Allocation - Paging
- Method
  - Divide **physical memory** into fixed-sized blocks called **frames**.
  - Divide **logical address space** into blocks of the same size called **pages**.
  - To run a program of n pages, need to find n free frames and load the program.
  - **Need to keep tracking the free frames**.
  - Set up a page table to translate logical to physical addresses.
- Benefit:
  - Allow the **physical-address space** of a process to be **noncontiguous**.
  - Avoid external fragmentation.
  - Limited internal fragmentation.
  - Provided **shared memory/pages**.
- Paging Example:
  - Page table: Each entry maps to the **base address of a page** in physical memory.
  - A data structure maintained by OS **for each process**.
    - Page table includes only pages owned by a process.
    - A process cannot access memory outside its space.
    - ![image](https://github.com/user-attachments/assets/b215a35e-810d-44a0-a4f0-44e228795060)
- Address Translation scheme
  - Logical address is divided into two parts:
    - Page number (p)
      - used as an index into a page table which contains **base address of each page** in physical memory.
      - $N$ bits means a process can allocate **at most $2^{N}$ pages**.
    - Page offset (d)
      - combined with base address to define the physical memory address that is sent to the memory unit.
      - $N$ bits means the **page size** is $2^{N}$.
  - Physical address= page **base address**+ **page **offset.
  - ![image](https://github.com/user-attachments/assets/1c2b5846-02d0-4f43-8f86-c069dcf99a34)
  - Given $32$ bits logical address, $36$ bits physical sddress and $4KB$ page size:
    - Page table size: $2^{32}/2^{12}=2^{20}$ entries.
    - Max program memory: $2^{32}$ = $4GB$.
    - Total physical memory size: $2^{36}=64GB$
    - Number of bits for page number: $2^{20}$pages = $20$ bits.
    - Number of bits for frame number: $2^{36}/2^{12}$ = $2^{24}$ frames = $24$ bits.
    - Number of bits for page offset: $4KB$ page size = $2^{12}$ bytes = $12$ bits.
  - Page/Frame size:
    - defined by hardware, a power of 2.
    - Ranging from 512 bytes to 16 MB/page.
    - 4KB/8KB is commonly used.
    - Larger page size = more internal fragmentation but page table is smaller.
    - Smaller page size = less internal fragmentation but page talbe is larger. 
- Implementation of page table:
  - Page table is kept **in memory**.
  - Page-table base register (PTBR):
    - The **physical memory address** of the page table.
    - The PTBR value is stored in PCB.
    - Changing the value of PTBR during **Context-switch**.
  - With PTBR, each memory reference results in 2 memory reads: one for the page table and one for the real address.
    - solution: Translation Look-aside Buffers (TLB), which is implemented by Associative memory.
    - Associative Memory:
      - All memory entries can be accessed at the same time (parallel search, $O(1)$), each entry corresponds to an associative register.
      - Number of entries are limited: typical numer of entries are 64 ~1024.
  - TLB: A cache for page table shared by all processes.
    - ![image](https://github.com/user-attachments/assets/5f8466db-7777-4756-a08c-f949797431bd)
    - TLB must **be flushed** after a context-switch, o.w. TLB entry must have a PID field (address-space identifiers (ASIDs)).

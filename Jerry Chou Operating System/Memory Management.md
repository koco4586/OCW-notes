# Address binding
  -Multistep processing of a user program:![image](https://github.com/user-attachments/assets/91f9ce2a-2b18-4444-95b9-4bf7d30ceead)
  - Address binding - Compile time:
    - Program is written as symbolic code.  
    - Compiler translates symbolic code into **absolute code**.
    - If starting location changes, need to recompile.
    - ![image](https://github.com/user-attachments/assets/f26742af-835a-41a9-adf3-2b78d8030c31)
  - Address binding - Load time:
    - Compiler translates symbolic code into **relocatable code**.
      - **Realocatable code**: Machine language that can be run from any memory location.
    - If stating location changes, need to reload the code.
    - ![image](https://github.com/user-attachments/assets/5574883e-0b9c-4bf7-b41a-af82d32818dd)
  - Address binding - Run time:
    - Compiler translates symbolic code into **logical-address (vitual-address) code**.
    - Special **hardware (MMU)** is needed for this scheme.
    - Most general-purpose OS use this method.
    - ![image](https://github.com/user-attachments/assets/f0e771d9-beef-4fd3-b531-23ff4d3ab839)
  - Memory-Management Unit (MMU)
    - Hardware device that **maps virtual to physical address**.
    - The value in the relocation register is added to every address generated by a user process at the time it is sent to memory.
    - Logical address (virtual address): generated by CPU.
    - Physical address: seen by the memory module.
    - Complie time and load time address binding: logical address = physical address.
    - Run time address binding: logical address != physical address.
    - The user program deals with logical addresses; it never sees the real physical addresses.
# Static/dynamic loading and linking
- Dynamic loading: A routine is loaded into memory when it is called.
  - Better memory-space utilization
    - unused routine is never loaded
    - Particularly useful when large amounts of code are infrequently used (e.g. **error handling code**).
  - No special support from OS is required implemented through program.
  - Dynamic loading examples in C:
    - *dlopen()*: open a library and prepares it for use.
    - *desym()*: looks up the value of a symbol in a given library.
    - *dlclose()*: closes a DL library.
- Static Linking: libraries are combined by the linker into the program's final in-memory image at compile time. At runtime, the loader loads the in-memory image for execution.
  - Waste memory: **dulicated code**.
  - Faster during execution time.
- Dynamic Linking: linking is postponed **until execution time**.
  - Only one copy of the library code is loaded into memory and shared by everyone.
  - A stub is included in the program in-memory image for each lib reference.
  - Stub call -> check if the referred lib is in memory -> if not, load the lib.
  - DLL(Dynamic Linking Library) in Windows.
# Swap
- A process can be swapped out of memory to a **backing store**, and later brought back into memory for continuous execution.
- Backing store: a chunk of disk, **separated from file system**, to provide direct access to these memory images.
- Swap back memory location:
  - If binding is done at complie/load time: swap back memory address must be the **same**.
  - If binding is done at execution time: swap back memory address can be **different**.
- A process to be swapped must be idle.
  - Solutions:
    - Never swap a process with pending I/O.
    - I/O operations are done through **OS buffers**.
# Contigous Memory Allocation
- Fixed-partition allocation:
  - Each process loads into one partition of fixed-size.
  - Degree of multi-programming is bounded by the number of partitions.
- Variable-size partition:
  - Hole: block of contiguous free memory.
  - Holes of various size are scattered in memory.
    - First-Fit: allocate the first hole that fits.
    - Best-Fit: allocate the smallest hole that fits.
      - Must search through the whole list, lower speed.
- Fragmentation:
  - External fragmentation:
    - Total free space is big enough to satisfy a request, but is not contigous.
    - Occur in Variable-size allocation.
  - Internal fragmentation:
    - Memory that is internal to a partition but is not being used.
    - Occur in fixed-partition allocation
  - Solution: compaction
    - Shuffle the memory contents to place all free memory together in one large block at **execution time**.
    - Only if binding is done at execution time.   
# Non-Contiguous Memory Allocation - Paging
- Method
  - Divide **physical memory** into fixed-sized blocks called **frames**.
  - Divide **logical address space** into blocks of the same size called **pages**.
  - To run a program of n pages, need to find n free frames and load the program.
  - **Need to keep tracking the free frames**.
  - Set up a page table to translate logical to physical addresses.
- Benefit:
  - Allow the **physical-address space** of a process to be **noncontiguous**.
  - Avoid external fragmentation.
  - Limited internal fragmentation.
  - Provided **shared memory/pages**.
- Paging Example:
  - Page table: Each entry maps to the **base address of a page** in physical memory.
  - A data structure maintained by OS **for each process**.
    - Page table includes only pages owned by a process.
    - A process cannot access memory outside its space. 
